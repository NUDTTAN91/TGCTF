<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TG CTF - é¶åœºä¸­å¿ƒ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;600;700;900&family=JetBrains+Mono:wght@400;700&family=Noto+Sans+SC:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #0a0a0a;
            --bg-card: #141414;
            --accent: #ff6b00;
            --text-main: #e0e0e0;
            --text-dim: #555;
            --success: #22c55e;
            --danger: #ef4444;
            --info: #3b82f6;
            --gold: #ffd700;
            --silver: #c0c0c0;
            --bronze: #cd7f32;
        }
        body { background-color: var(--bg-dark); color: var(--text-main); font-family: 'Noto Sans SC', sans-serif; overflow: hidden; }
        .font-eng { font-family: 'Chakra Petch', sans-serif; }
        .font-mono { font-family: 'JetBrains Mono', monospace; }

        /* === å·¦ä¾§æ æ ·å¼ === */
        .stat-grid-item { background: #1a1a1a; padding: 8px; border: 1px solid #2a2a2a; }
        .stat-label { font-size: 10px; color: #555; font-family: 'JetBrains Mono', monospace; }
        .stat-value { font-size: 14px; font-weight: bold; font-family: 'Chakra Petch', sans-serif; color: white; }

        /* æˆ˜å†µæ—¥å¿— */
        .event-item {
            padding: 10px 0; border-bottom: 1px solid #1a1a1a; font-family: 'Noto Sans SC', sans-serif; font-size: 0.75rem;
            display: flex; flex-direction: column; gap: 4px; transition: 0.2s; opacity: 0.7;
        }
        .event-item:hover { opacity: 1; background: rgba(255,255,255,0.02); padding-left: 4px; }
        
        .tag-event { padding: 1px 4px; border-radius: 2px; font-weight: bold; font-size: 0.65rem; display: inline-block; width: fit-content; font-family: 'JetBrains Mono', monospace; }
        .tag-blood { background: rgba(239, 68, 68, 0.2); color: var(--danger); border: 1px solid rgba(239, 68, 68, 0.4); }
        .tag-new { background: rgba(34, 197, 94, 0.2); color: var(--success); border: 1px solid rgba(34, 197, 94, 0.4); }
        .tag-hint { background: rgba(59, 130, 246, 0.2); color: var(--info); border: 1px solid rgba(59, 130, 246, 0.4); }
        .tag-sys { background: #222; color: #888; border: 1px solid #444; }

        /* === é¡¶éƒ¨æ ·å¼ === */
        .countdown-box {
            font-family: 'Chakra Petch', sans-serif; font-weight: 700; font-size: 1.5rem;
            color: white; text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
            display: flex; gap: 0.5rem; align-items: center;
        }
        .time-unit { background: #111; border: 1px solid #333; padding: 0 8px; border-radius: 2px; min-width: 40px; text-align: center; color: var(--accent); }

        /* å¼€å…³ */
        .tactical-toggle { position: relative; display: inline-block; width: 36px; height: 18px; flex-shrink: 0; }
        .tactical-toggle input { opacity: 0; width: 0; height: 0; }
        .toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #333; transition: .4s; border: 1px solid #555; }
        .toggle-slider:before { position: absolute; content: ""; height: 10px; width: 10px; left: 3px; bottom: 3px; background-color: #888; transition: .4s; }
        input:checked + .toggle-slider { background-color: rgba(255, 107, 0, 0.2); border-color: var(--accent); }
        input:checked + .toggle-slider:before { transform: translateX(18px); background-color: var(--accent); }

        /* åˆ†ç±»æŒ‰é’® */
        .cat-btn {
            padding: 8px 24px; font-family: 'Noto Sans SC', sans-serif; font-weight: bold; font-size: 0.875rem;
            border: 1px solid transparent; color: #666; transition: all 0.2s; cursor: pointer;
            position: relative; overflow: hidden; white-space: nowrap;
        }
        .cat-btn:hover { color: white; background: rgba(255,255,255,0.05); }
        .cat-btn.active {
            color: black; background: var(--accent); border-color: var(--accent);
            box-shadow: 0 0 15px rgba(255, 107, 0, 0.4);
            clip-path: polygon(10px 0, 100% 0, 100% 100%, 0 100%, 0 10px);
        }

        /* === é¢˜ç›®å¡ç‰‡ === */
        .module-card {
            background: #111; border: 1px solid #333; position: relative; height: 160px;
            display: flex; flex-direction: column; justify-content: space-between; transition: all 0.3s; overflow: hidden;
            background-image: radial-gradient(#222 1px, transparent 1px); background-size: 10px 10px; cursor: pointer;
        }
        .module-card::before {
            content: ''; position: absolute; top: 0; right: 0;
            border-top: 20px solid var(--cat-color, var(--accent)); border-left: 20px solid transparent; opacity: 0; transition: 0.3s;
        }
        .module-card:hover { border-color: #666; transform: translateY(-4px); box-shadow: 0 10px 30px -10px rgba(0,0,0,0.5); }
        .module-card:hover::before { opacity: 1; }

        .module-card:hover .card-title { color: var(--cat-color, var(--accent)); }
        .module-normal:hover .status-bar { background: var(--cat-color, var(--accent)); }
        .module-solved { opacity: 0.5; border-color: #222; background-image: none; }
        .module-solved:hover { opacity: 1; border-color: var(--success); }
        .module-solved .status-bar { background: var(--success); }
        .module-solved::before { display: none; }
        
        .module-blood { border-color: #500; background: rgba(50, 0, 0, 0.2); }
        .module-blood:hover { border-color: var(--danger); box-shadow: 0 0 20px rgba(239, 68, 68, 0.2); }
        .module-blood .status-bar { background: var(--danger); }
        .blood-anim { animation: pulse-red 2s infinite; }
        @keyframes pulse-red { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }

        .status-bar { height: 3px; width: 100%; background: #333; transition: 0.3s; }

        /* ä¸‰è¡€æ¡ */
        .blood-bar { display: flex; gap: 4px; padding-top: 8px; margin-top: auto; border-top: 1px solid #222; }
        .blood-item {
            flex: 1; height: 24px; display: flex; align-items: center; gap: 4px; 
            font-size: 0.65rem; font-family: 'JetBrains Mono', monospace; color: #666;
            background: rgba(255,255,255,0.02); padding: 0 4px; border-radius: 2px; overflow: hidden; white-space: nowrap;
        }
        .medal-dot { width: 6px; height: 6px; border-radius: 50%; display: inline-block; flex-shrink: 0; }
        .medal-gold { background: var(--gold); box-shadow: 0 0 5px var(--gold); }
        .medal-silver { background: var(--silver); }
        .medal-bronze { background: var(--bronze); }

        /* === å¼¹çª— === */
        #modal-overlay.hidden { display: none; }
        #modal-overlay:not(.hidden) { display: flex; align-items: center; justify-content: center; }

        .attachment-card { background: #1a1a1a; border: 1px solid #333; padding: 12px; display: flex; align-items: center; gap: 12px; transition: all 0.2s; cursor: pointer; width: fit-content; }
        .attachment-card:hover { border-color: var(--accent); background: rgba(255, 107, 0, 0.05); }
        .file-icon { width: 32px; height: 32px; background: #222; display: flex; align-items: center; justify-content: center; border-radius: 4px; color: #888; font-size: 1.2rem; }

        .hint-box { border: 1px dashed #444; margin-bottom: 8px; overflow: hidden; }
        .hint-header { padding: 10px 14px; background: rgba(255,255,255,0.02); cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-size: 0.8rem; font-family: 'JetBrains Mono', monospace; color: #888; transition: 0.2s; }
        .hint-header:hover { color: white; background: rgba(255,255,255,0.05); }
        .hint-content { padding: 14px; font-size: 0.85rem; color: #ccc; border-top: 1px dashed #444; background: #111; display: none; }
        .hint-box.open .hint-content { display: block; }

        .btn-launch {
            width: 100%; height: 50px; background: rgba(255, 107, 0, 0.05); border: 1px dashed var(--accent); color: var(--accent); font-family: 'Chakra Petch', sans-serif; font-weight: bold; font-size: 0.9rem; letter-spacing: 0.1em; transition: all 0.3s; display: flex; align-items: center; justify-content: center; gap: 8px; cursor: pointer;
        }
        .btn-launch:hover { background: var(--accent); color: black; border-style: solid; box-shadow: 0 0 20px rgba(255, 107, 0, 0.3); }

        .instance-panel { display: none; margin-top: 10px; }
        .instance-panel.active { display: block; }

        .instance-row { background: #000; border: 1px solid #333; padding: 12px 16px; display: flex; gap: 8px; align-items: center; font-family: 'JetBrains Mono', monospace; font-size: 0.9rem; color: var(--info); margin-bottom: 8px; }
        .copy-icon { opacity: 0.5; cursor: pointer; transition: 0.2s; }
        .copy-icon:hover { opacity: 1; color: white; }

        .tactical-input { background: #000; border: 1px solid #333; color: white; padding: 0 16px; height: 48px; width: 100%; outline: none; font-family: 'JetBrains Mono', monospace; transition: 0.2s; font-size: 0.9rem; }
        .tactical-input:focus { border-color: var(--accent); }
        
        .btn-submit-new { height: 48px; padding: 0 32px; background: var(--accent); color: black; font-weight: 900; font-family: 'Chakra Petch', sans-serif; letter-spacing: 0.1em; clip-path: polygon(10px 0, 100% 0, 100% 100%, 0 100%, 0 10px); transition: 0.2s; display: flex; align-items: center; justify-content: center; white-space: nowrap; }
        .btn-submit-new:hover { background: white; transform: translateY(-2px); box-shadow: 0 5px 15px rgba(255,107,0,0.4); }

        /* æ»šåŠ¨æ¡ */
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: #0a0a0a; }
        ::-webkit-scrollbar-thumb { background: #333; }
        ::-webkit-scrollbar-thumb:hover { background: var(--accent); }

        /* ç¡®è®¤å¼¹çª— */
        #confirm-overlay { transition: opacity 0.15s; }
        #confirm-overlay.hidden { opacity: 0; pointer-events: none; }
        #confirm-box { background: #1a1a1a; border: 1px solid #333; padding: 24px; min-width: 320px; }
        .confirm-title { font-size: 1rem; font-weight: bold; color: white; margin-bottom: 12px; }
        .confirm-msg { font-size: 0.875rem; color: #888; margin-bottom: 20px; }
        .confirm-btns { display: flex; gap: 12px; justify-content: flex-end; }
        .confirm-btn { padding: 8px 20px; font-size: 0.8rem; font-weight: bold; border: 1px solid #444; cursor: pointer; transition: 0.2s; }
        .confirm-btn-cancel { background: transparent; color: #888; }
        .confirm-btn-cancel:hover { background: #222; color: white; }
        .confirm-btn-danger { background: var(--danger); color: white; border-color: var(--danger); }
        .confirm-btn-danger:hover { background: #dc2626; }
    </style>
</head>
<body class="flex h-screen w-screen selection:bg-[#ff6b00] selection:text-black bg-[#0a0a0a]">

    <!-- å·¦ä¾§æ§åˆ¶å° -->
    <aside class="w-80 bg-[#0d0d0d] border-r border-[#222] flex flex-col z-20 shrink-0 relative">
        <div class="h-20 flex items-center px-6 border-b border-[#222]">
            <a href="/home.html" class="text-2xl font-black font-eng text-white tracking-tighter hover:text-[#ff6b00] transition">
                TG <span class="text-[#ff6b00]">_</span> CTF
            </a>
        </div>

        <!-- 1. ç”¨æˆ·ä¿¡æ¯ -->
        <div id="user-info-panel" class="p-6 border-b border-[#222] bg-[#111]">
            <div class="flex items-center gap-4 mb-4">
                <div class="w-12 h-12 bg-[#222] border border-[#444] rounded flex items-center justify-center relative shadow-lg overflow-hidden">
                    <img id="user-avatar-img" src="" alt="" class="w-full h-full object-cover hidden">
                    <span id="user-avatar" class="text-lg font-bold text-gray-400">U</span>
                    <div class="absolute -bottom-1 -right-1 w-3 h-3 bg-green-500 border-2 border-[#111] rounded-full"></div>
                </div>
                <div>
                    <div id="user-display-name" class="text-white font-bold font-eng tracking-wide text-lg">ç”¨æˆ·å</div>
                    <div id="user-uid" class="text-[10px] text-gray-500 font-mono">UID: --</div>
                </div>
            </div>
            <div id="stats-panel" class="grid grid-cols-2 gap-y-3 gap-x-2">
                <div class="stat-grid-item">
                    <div class="stat-label">æˆ˜é˜Ÿæ’å</div>
                    <div id="stat-team-rank" class="stat-value text-[#ff6b00]">--</div>
                </div>
                <div class="stat-grid-item">
                    <div class="stat-label">ä¸ªäººæ’å</div>
                    <div id="stat-user-rank" class="stat-value text-white">--</div>
                </div>
                <div class="stat-grid-item">
                    <div class="stat-label">ä¸ªäººè§£é¢˜</div>
                    <div id="stat-solved" class="stat-value text-white">0</div>
                </div>
                <div class="stat-grid-item">
                    <div class="stat-label">æ€»ç§¯åˆ†</div>
                    <div id="stat-score" class="stat-value text-white">0</div>
                </div>
            </div>
        </div>

        <!-- 2. æ¯”èµ›å…¬å‘Š -->
        <div class="flex-1 flex flex-col min-h-0 bg-[#0a0a0a]">
            <div class="px-4 py-3 border-b border-[#222] bg-[#0f0f0f] flex justify-between items-center">
                <span class="text-[10px] font-mono text-gray-500 uppercase tracking-widest flex items-center gap-2">
                    <span class="w-1.5 h-1.5 bg-green-500 rounded-full animate-pulse"></span> æ¯”èµ›å…¬å‘Š
                </span>
                <span class="text-[10px] text-[#333]">AUTO-REFRESH</span>
            </div>
            
            <div class="flex-1 overflow-y-auto p-4 space-y-2" id="event-log">
                <div class="event-item">
                    <div class="flex justify-between items-center"><span class="tag-event tag-sys">ç³»ç»Ÿ</span><span class="text-gray-600 font-mono">--:--:--</span></div>
                    <p class="text-gray-400">ç­‰å¾…æˆ˜æŠ¥æ•°æ®...</p>
                </div>
            </div>
        </div>
        <div class="p-3 text-[10px] text-[#333] text-center font-mono border-t border-[#222]">TG_OS v2.0.4</div>
    </aside>

    <!-- å³ä¾§å†…å®¹åŒº -->
    <main class="flex-1 flex flex-col min-w-0 relative z-10 bg-[#0a0a0a]">
        
        <!-- 1. é¡¶éƒ¨ Header -->
        <header class="h-20 flex items-center justify-between px-8 border-b border-[#222] bg-[#0a0a0a] shrink-0">
            <div class="flex flex-col">
                <h1 id="contest-name" class="text-lg font-bold text-white font-eng tracking-wide">æ¯”èµ›åç§°</h1>
                <span id="contest-mode" class="text-xs text-gray-500 font-mono">åŠ è½½ä¸­...</span>
            </div>

            <!-- å€’è®¡æ—¶ -->
            <div class="flex flex-col items-center">
                <span class="text-[10px] text-[#ff6b00] font-mono mb-1 tracking-[0.2em] uppercase">å‰©ä½™æ—¶é—´</span>
                <div class="countdown-box">
                    <span id="cd-hours" class="time-unit">--</span> : <span id="cd-minutes" class="time-unit">--</span> : <span id="cd-seconds" class="time-unit">--</span>
                </div>
            </div>

            <div class="flex items-center gap-4">
                <a href="javascript:void(0)" onclick="goToLeaderboard()" class="flex items-center gap-2 px-4 py-2 bg-[#111] border border-[#333] hover:border-[#ff6b00] text-gray-400 hover:text-[#ff6b00] transition font-mono text-xs">
                    <span>ğŸ“Š</span>
                    <span>æ’è¡Œæ¦œ</span>
                </a>
                <input type="text" id="search-input" placeholder="æœç´¢é¢˜ç›®..." class="bg-black border border-[#333] text-xs text-white px-3 py-1.5 w-48 outline-none font-mono focus:border-[#ff6b00] transition">
                <label class="flex items-center gap-2 cursor-pointer select-none group">
                    <span class="text-[10px] text-gray-500 font-mono group-hover:text-gray-300">éšè—å·²è§£å‡º</span>
                    <label class="tactical-toggle"><input type="checkbox" id="hide-solved"><span class="toggle-slider"></span></label>
                </label>
            </div>
        </header>

        <!-- 2. åˆ†ç±»ç­›é€‰æ  -->
        <div class="h-14 border-b border-[#222] bg-[#0d0d0d] flex items-center px-8 gap-4 overflow-x-auto" id="category-bar">
            <button class="cat-btn active" data-category="ALL">å…¨éƒ¨ (0)</button>
            <!-- åˆ†ç±»æŒ‰é’®ç”± JS åŠ¨æ€ç”Ÿæˆ -->
        </div>

        <!-- 3. é¢˜ç›®åˆ—è¡¨ -->
        <div class="flex-1 overflow-y-auto p-8">
            <div id="challenges-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 2xl:grid-cols-5 gap-4">
                <!-- åŠ¨æ€åŠ è½½é¢˜ç›®å¡ç‰‡ -->
            </div>
        </div>
    </main>

    <!-- é¢˜ç›®è¯¦æƒ…å¼¹çª— -->
    <div id="modal-overlay" class="fixed inset-0 z-50 items-center justify-center bg-black bg-opacity-90 hidden">
        <div id="modal-content" class="bg-[#141414] border border-[#333] w-full max-w-7xl h-[85vh] shadow-2xl flex overflow-hidden relative">
            
            <button onclick="closeModal()" class="absolute top-6 right-6 text-gray-500 hover:text-white z-20 text-2xl transition transform hover:rotate-90">âœ•</button>

            <!-- å·¦ä¾§ï¼šä½œæˆ˜åŒº (75%) -->
            <div class="w-[75%] p-12 flex flex-col border-r border-[#222] relative">
                <div class="mb-8">
                    <div class="flex items-center gap-3 mb-2">
                        <span id="modal-category" class="text-[10px] font-mono text-[#ff6b00] border border-[#ff6b00]/30 px-2 py-0.5 bg-[#ff6b00]/5">WEB</span>
                        <span id="modal-score" class="text-4xl font-black font-eng text-white">100 PTS</span>
                    </div>
                    <h2 id="modal-title" class="text-4xl font-bold text-white font-eng tracking-wide">é¢˜ç›®åç§°</h2>
                </div>

                <div class="flex-grow overflow-y-auto pr-6 custom-scrollbar mb-6">
                    <div id="modal-description" class="text-base text-gray-400 leading-8 font-mono mb-10" style="word-break: break-word; white-space: pre-wrap;">
                        <p class="mb-6">é¢˜ç›®æè¿°åŠ è½½ä¸­...</p>
                    </div>

                    <!-- é™„ä»¶ -->
                    <div id="attachment-section" class="mb-10 hidden">
                        <p class="text-xs text-gray-600 font-mono mb-3 uppercase tracking-wider">é™„ä»¶ä¸‹è½½</p>
                        <div id="attachment-list" class="flex flex-wrap gap-4"></div>
                    </div>

                    <!-- æç¤º -->
                    <div id="hints-section" class="mb-8 hidden">
                        <p class="text-xs text-gray-600 font-mono mb-3 uppercase tracking-wider">é¢˜ç›®æç¤º</p>
                        <div id="hints-list"></div>
                    </div>
                </div>

                <div class="mt-auto pt-8 border-t border-[#333]">
                    <!-- åŠ¨æ€å®¹å™¨éƒ¨ç½²åŒºåŸŸ -->
                    <div id="deploy-section" class="mb-8" style="display:none;">
                        <button id="btn-deploy" class="btn-launch" onclick="deployInstance()" style="display:none;">
                            <span>ğŸš€ éƒ¨ç½²ä½œæˆ˜ç¯å¢ƒ (DEPLOY INSTANCE)</span>
                        </button>
                        <!-- éƒ¨ç½²è¿›åº¦æ¡ -->
                        <div id="deploy-progress-panel" class="instance-panel" style="display:none;">
                            <div class="text-center mb-4">
                                <span class="text-sm text-[#ff6b00] font-mono">ğŸš€ æ­£åœ¨éƒ¨ç½²ä½œæˆ˜ç¯å¢ƒ...</span>
                            </div>
                            <div class="w-full h-2 bg-[#222] rounded overflow-hidden">
                                <div id="deploy-progress-bar" class="h-full bg-[#ff6b00] transition-all duration-100" style="width: 0%"></div>
                            </div>
                            <div class="text-center mt-2">
                                <span id="deploy-progress-text" class="text-xs text-gray-500 font-mono">0%</span>
                            </div>
                        </div>
                        <div id="instance-panel" class="instance-panel">
                            <div class="flex justify-between items-center mb-3">
                                <span class="text-xs text-gray-500 font-mono uppercase tracking-widest flex items-center gap-2">
                                    <span class="w-2 h-2 bg-green-500 rounded-full animate-pulse"></span> Active Instance
                                    <span id="instance-creator-info" class="text-yellow-500 ml-2" style="display:none;"></span>
                                </span>
                                <div class="text-xs text-gray-500 flex gap-4">
                                    <span>å‰©ä½™æ—¶é—´: <span id="instance-ttl" class="text-white font-bold">--:--</span></span>
                                    <button class="text-[#ff6b00] hover:text-white hover:underline" onclick="extendInstance()">å»¶é•¿</button>
                                    <button id="btn-destroy" class="text-red-500 hover:text-white hover:underline" onclick="destroyInstance()">é”€æ¯</button>
                                </div>
                            </div>
                            <div id="instance-addresses" class="flex flex-col gap-2">
                                <!-- åŠ¨æ€å¡«å……å®¹å™¨åœ°å€ -->
                            </div>
                        </div>
                    </div>

                    <div class="flex gap-4">
                        <input type="text" id="flag-input" class="tactical-input" placeholder="TG{flag_here...}">
                        <button onclick="submitFlag()" class="btn-submit-new w-56 shadow-lg">æäº¤ // SUBMIT</button>
                    </div>
                </div>
            </div>

            <!-- å³ä¾§ï¼šæ¦œå• (25%) -->
            <div class="w-[25%] bg-[#111] flex flex-col border-l border-[#222]">
                <div class="p-6 border-b border-[#222] bg-[#161616]"><h3 class="text-xs font-bold text-gray-400 font-mono uppercase tracking-wider">è§£é¢˜æ¦œ</h3></div>
                <div class="flex-1 overflow-y-auto p-0 custom-scrollbar">
                    <table class="w-full text-left text-[10px] font-mono">
                        <tbody id="solvers-list" class="divide-y divide-[#222]">
                            <!-- åŠ¨æ€åŠ è½½ -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- ç¡®è®¤å¼¹çª— -->
    <div id="confirm-overlay" class="fixed inset-0 z-[60] flex items-center justify-center bg-black bg-opacity-80 hidden">
        <div id="confirm-box">
            <div class="confirm-title" id="confirm-title">ç¡®è®¤æ“ä½œ</div>
            <div class="confirm-msg" id="confirm-msg">ç¡®å®šè¦æ‰§è¡Œæ­¤æ“ä½œå—ï¼Ÿ</div>
            <div class="confirm-btns">
                <button class="confirm-btn confirm-btn-cancel" onclick="hideConfirm()">å–æ¶ˆ</button>
                <button class="confirm-btn confirm-btn-danger" id="confirm-ok-btn">ç¡®å®š</button>
            </div>
        </div>
    </div>

    <!-- å°ç¦é®ç½©å±‚ -->
    <div id="banned-overlay" class="fixed inset-0 z-[100] flex items-center justify-center hidden" style="background: rgba(50, 50, 50, 0.95);">
        <div class="text-center">
            <div class="text-6xl mb-6">ğŸš«</div>
            <div class="text-3xl font-bold text-red-500 mb-4">æ‚¨çš„é˜Ÿä¼å·²è¢«å°ç¦ï¼</div>
            <div id="banned-reason" class="text-gray-400 text-sm mb-8"></div>
            <a href="/home.html" class="inline-block px-6 py-3 bg-[#333] text-white hover:bg-[#444] transition">è¿”å›é¦–é¡µ</a>
        </div>
    </div>

    <script>
        const token = localStorage.getItem('tg_token');
        let contestId = null;
        let contestData = null;
        let challengesData = [];
        let categories = [];  // ç±»åˆ«åˆ—è¡¨
        let currentCategory = 'ALL';
        let currentChallengeId = null;
        let isAdminMode = false;
        let userInfo = null;
        let teamSolves = [];  // é˜Ÿä¼å·²è§£é¢˜ç›®
        let totalScore = 0;   // é˜Ÿä¼æ€»åˆ†

        function parseJwt(token) {
            try {
                const base64Url = token.split('.')[1];
                const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
                const jsonPayload = decodeURIComponent(atob(base64).split('').map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)).join(''));
                return JSON.parse(jsonPayload);
            } catch (e) { return null; }
        }

        // æƒé™æ£€æŸ¥
        if (!token) {
            window.location.href = '/login.html';
        }
        
        // éªŒè¯ token æ˜¯å¦æœ‰æ•ˆï¼ˆé‡ç½®å¯†ç åä¼šå¤±æ•ˆï¼‰
        async function validateToken() {
            try {
                const resp = await fetch('/api/profile', {
                    headers: { 'Authorization': 'Bearer ' + token }
                });
                if (resp.status === 401) {
                    localStorage.removeItem('tg_token');
                    localStorage.removeItem('tg_must_change_password');
                    window.location.href = '/login.html';
                }
            } catch (e) {
                console.error('Token validation failed', e);
            }
        }
        validateToken();
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦å¼ºåˆ¶ä¿®æ”¹å¯†ç ï¼ˆé˜²ç»•è¿‡ï¼‰
        if (localStorage.getItem('tg_must_change_password') === 'true') {
            alert('è¯·å…ˆä¿®æ”¹å¯†ç åå†è®¿é—®ç³»ç»Ÿ');
            window.location.href = '/change-password.html';
        }
        
        const payload = parseJwt(token);
        if (!payload) {
            window.location.href = '/login.html';
        } else {
            userInfo = payload;
            // è¶…çº§ç®¡ç†å‘˜æ¨¡å¼
            if (payload.role === 'super') {
                isAdminMode = true;
            }
        }

        // è·å–æ¯”èµ›ID
        const urlParams = new URLSearchParams(window.location.search);
        contestId = urlParams.get('id');
        if (!contestId) {
            alert('æœªæŒ‡å®šæ¯”èµ›ID');
            window.location.href = '/contests.html';
        }

        // åˆå§‹åŒ–é¡µé¢
        async function init() {
            // è®¾ç½®ç”¨æˆ·ä¿¡æ¯
            if (userInfo) {
                document.getElementById('user-display-name').textContent = userInfo.displayName || userInfo.username;
                document.getElementById('user-uid').textContent = `UID: ${userInfo.sub}`;
                // åŠ è½½ç”¨æˆ·å¤´åƒ
                loadUserAvatar();
            }

            // æ£€æŸ¥é˜Ÿä¼å®¡æ ¸çŠ¶æ€ï¼ˆéç®¡ç†å‘˜ï¼‰
            if (!isAdminMode) {
                const canEnter = await checkTeamApprovalStatus();
                if (!canEnter) return; // æœªé€šè¿‡å®¡æ ¸ï¼Œä¸ç»§ç»­åŠ è½½
            }

            await loadContest();
            await loadCategories();  // åŠ è½½ç±»åˆ«é¢œè‰²
            await loadChallenges();
            await loadTeamSolves();
            await loadAnnouncements(); // åŠ è½½å…¬å‘Š
            startCountdown();
        }

        // æ£€æŸ¥é˜Ÿä¼å®¡æ ¸çŠ¶æ€ï¼ˆåŒ…æ‹¬å°ç¦ã€å¾…å®¡æ ¸ã€æœªæŠ¥åç­‰ï¼‰
        async function checkTeamApprovalStatus() {
            try {
                const res = await fetch(`/api/contests/${contestId}/team-status`, {
                    headers: { 'Authorization': 'Bearer ' + token }
                });
                if (!res.ok) {
                    showAccessDenied('æ— æ³•è·å–é˜Ÿä¼çŠ¶æ€');
                    return false;
                }
                const data = await res.json();
                
                // æ£€æŸ¥æ˜¯å¦å¯ä»¥è¿›å…¥æ¯”èµ›
                if (!data.canEnter) {
                    showAccessDenied(data.message || 'æ‚¨æ— æƒè®¿é—®è¯¥æ¯”èµ›');
                    return false;
                }
                
                // æ£€æŸ¥æ˜¯å¦è¢«å°ç¦
                if (data.status === 'banned' || data.status === 'cheating_banned') {
                    showBannedOverlay(data.status, data.message);
                    return false;
                }
                
                return true;
            } catch (e) {
                console.error('Check team status error:', e);
                showAccessDenied('æ£€æŸ¥é˜Ÿä¼çŠ¶æ€å¤±è´¥');
                return false;
            }
        }

        // æ˜¾ç¤ºè®¿é—®æ‹’ç»é®ç½©
        function showAccessDenied(message) {
            const overlay = document.getElementById('banned-overlay');
            const reasonEl = document.getElementById('banned-reason');
            const titleEl = overlay.querySelector('h2');
            if (titleEl) titleEl.textContent = 'è®¿é—®å—é™';
            reasonEl.textContent = message;
            overlay.classList.remove('hidden');
        }

        // æ˜¾ç¤ºå°ç¦é®ç½©
        function showBannedOverlay(status, message) {
            const overlay = document.getElementById('banned-overlay');
            const reasonEl = document.getElementById('banned-reason');
            if (status === 'cheating_banned') {
                reasonEl.textContent = 'åŸå› ï¼šå› ä½œå¼Šè¡Œä¸ºè¢«å°ç¦';
            } else {
                reasonEl.textContent = message || '';
            }
            overlay.classList.remove('hidden');
        }

        // æ£€æŸ¥é˜Ÿä¼æ˜¯å¦è¢«å°ç¦ï¼ˆå®šæ—¶æ£€æŸ¥ï¼‰
        async function checkBannedStatus() {
            try {
                const res = await fetch(`/api/contests/${contestId}/team-status`, {
                    headers: { 'Authorization': 'Bearer ' + token }
                });
                if (!res.ok) return;
                const data = await res.json();
                
                if (data.status === 'banned' || data.status === 'cheating_banned') {
                    // æ˜¾ç¤ºå°ç¦é®ç½©
                    const overlay = document.getElementById('banned-overlay');
                    const reasonEl = document.getElementById('banned-reason');
                    
                    if (data.status === 'cheating_banned') {
                        reasonEl.textContent = 'åŸå› ï¼šå› ä½œå¼Šè¡Œä¸ºè¢«å°ç¦';
                    } else {
                        reasonEl.textContent = data.message || '';
                    }
                    
                    overlay.classList.remove('hidden');
                }
            } catch (e) {
                console.error('Check banned status error:', e);
            }
        }

        // åŠ è½½é˜Ÿä¼è§£é¢˜æƒ…å†µ
        async function loadTeamSolves() {
            if (isAdminMode) return;
            try {
                const res = await fetch(`/api/contests/${contestId}/solves`, {
                    headers: { 'Authorization': 'Bearer ' + token }
                });
                if (res.ok) {
                    const data = await res.json();
                    teamSolves = data.solves || [];
                    totalScore = data.totalScore || 0;
                    const myTeamId = data.teamId;
                    document.getElementById('stat-score').textContent = totalScore;
                    document.getElementById('stat-solved').textContent = teamSolves.length;
                    
                    // åŠ è½½æ’è¡Œæ¦œå¹¶è®¡ç®—æ’å
                    await loadAndUpdateRank(myTeamId);
                    
                    renderChallenges();
                }
            } catch (e) {
                console.error('Load solves error:', e);
            }
        }

        // åŠ è½½æ’è¡Œæ¦œå¹¶æ›´æ–°æ’å
        async function loadAndUpdateRank(myTeamId) {
            try {
                const res = await fetch(`/api/contests/${contestId}/scoreboard`, {
                    headers: { 'Authorization': 'Bearer ' + token }
                });
                if (!res.ok) return;
                const scoreboard = await res.json() || [];
                
                // è®¡ç®—æˆ˜é˜Ÿæ’å
                let teamRank = '--';
                for (let i = 0; i < scoreboard.length; i++) {
                    if (scoreboard[i].teamId === myTeamId) {
                        teamRank = i + 1;
                        break;
                    }
                }
                document.getElementById('stat-team-rank').textContent = teamRank;
                
                // ä¸ªäººæ’åï¼šæš‚æ—¶ä¸æˆ˜é˜Ÿæ’åç›¸åŒï¼ˆåç»­å¯æ‰©å±•ä¸ºä¸ªäººè§£é¢˜æ’åï¼‰
                document.getElementById('stat-user-rank').textContent = teamRank;
            } catch (e) {
                console.error('Load scoreboard error:', e);
            }
        }

        // åŠ è½½æ¯”èµ›ä¿¡æ¯
        async function loadContest() {
            try {
                const res = await fetch(`/api/contests/${contestId}`, {
                    headers: { 'Authorization': 'Bearer ' + token }
                });
                if (!res.ok) throw new Error('Failed');
                contestData = await res.json();
                
                // AWD-F æ¨¡å¼è·³è½¬åˆ°ä¸“ç”¨é¡µé¢
                if (contestData.mode === 'awd-f') {
                    window.location.href = `/contest-challenges-awdf.html?id=${contestId}`;
                    return;
                }
                
                document.getElementById('contest-name').textContent = contestData.name;
                document.getElementById('contest-mode').textContent = contestData.mode === 'jeopardy' ? 'è§£é¢˜èµ› (Jeopardy)' : 'AWD æ”»é˜²èµ›';
                document.title = `TG CTF - ${contestData.name}`;
            } catch (e) {
                console.error(e);
                alert('åŠ è½½æ¯”èµ›ä¿¡æ¯å¤±è´¥');
            }
        }

        // åŠ è½½ç±»åˆ«åˆ—è¡¨
        async function loadCategories() {
            try {
                const res = await fetch('/api/categories', {
                    headers: { 'Authorization': 'Bearer ' + token }
                });
                if (res.ok) {
                    categories = await res.json() || [];
                    // æŒ‰ displayOrder æ’åº
                    categories.sort((a, b) => (a.displayOrder || 999) - (b.displayOrder || 999));
                    // åŠ¨æ€ç”Ÿæˆåˆ†ç±»æŒ‰é’®
                    renderCategoryButtons();
                }
            } catch (e) {
                console.error('Load categories error:', e);
            }
        }

        // åŠ¨æ€æ¸²æŸ“åˆ†ç±»æŒ‰é’®
        function renderCategoryButtons() {
            const bar = document.getElementById('category-bar');
            // ä¿ç•™ç¬¬ä¸€ä¸ª"å…¨éƒ¨"æŒ‰é’®ï¼Œç§»é™¤å…¶ä»–åŠ¨æ€æŒ‰é’®
            const allBtn = bar.querySelector('[data-category="ALL"]');
            bar.innerHTML = '';
            bar.appendChild(allBtn);
            
            // æ ¹æ®åç«¯åˆ†ç±»æ•°æ®ç”ŸæˆæŒ‰é’®
            categories.forEach(cat => {
                const btn = document.createElement('button');
                btn.className = 'cat-btn';
                btn.dataset.category = cat.name.toUpperCase();
                btn.textContent = `${cat.name} (0)`;
                bar.appendChild(btn);
            });
        }

        // æ ¹æ®ç±»åˆ«åç§°è·å–å‘å…‰é¢œè‰²
        function getCategoryColor(categoryName) {
            const cat = categories.find(c => c.name && c.name.toUpperCase() === (categoryName || '').toUpperCase());
            return cat && cat.glowColor ? cat.glowColor : '#ff6b00';
        }

        // åŠ è½½é¢˜ç›®åˆ—è¡¨
        async function loadChallenges() {
            try {
                const res = await fetch(`/api/contests/${contestId}/challenges`, {
                    headers: { 'Authorization': 'Bearer ' + token }
                });
                if (!res.ok) throw new Error('Failed');
                challengesData = await res.json() || [];
                
                updateCategoryCounts();
                renderChallenges();
                
                // ç«‹å³åŠ è½½ä¸€äºŒä¸‰è¡€æ•°æ®
                loadAllBloodStats();
            } catch (e) {
                console.error(e);
            }
        }

        // æ›´æ–°åˆ†ç±»è®¡æ•°
        function updateCategoryCounts() {
            // åŠ¨æ€ç»Ÿè®¡å„åˆ†ç±»çš„é¢˜ç›®æ•°é‡
            const counts = { ALL: challengesData.length };
            challengesData.forEach(ch => {
                const cat = (ch.category || '').toUpperCase();
                counts[cat] = (counts[cat] || 0) + 1;
            });

            // å¦‚æœå½“å‰é€‰ä¸­çš„åˆ†ç±»é¢˜ç›®æ•°ä¸º0ï¼Œè‡ªåŠ¨åˆ‡å›"å…¨éƒ¨"
            if (currentCategory !== 'ALL' && (counts[currentCategory] || 0) === 0) {
                currentCategory = 'ALL';
            }

            document.querySelectorAll('.cat-btn').forEach(btn => {
                const cat = btn.dataset.category;
                // æ›´æ–° active çŠ¶æ€
                btn.classList.toggle('active', cat === currentCategory);
                
                if (cat === 'ALL') {
                    btn.textContent = `å…¨éƒ¨ (${counts.ALL})`;
                    btn.style.display = '';  // "å…¨éƒ¨"æŒ‰é’®å§‹ç»ˆæ˜¾ç¤º
                } else {
                    const count = counts[cat] || 0;
                    if (count === 0) {
                        // è¯¥åˆ†ç±»æ— é¢˜ç›®ï¼Œéšè—æŒ‰é’®
                        btn.style.display = 'none';
                    } else {
                        btn.style.display = '';
                        // ä» categories ä¸­æ‰¾åˆ°å¯¹åº”åˆ†ç±»è·å–æ˜¾ç¤ºåç§°
                        const catInfo = categories.find(c => c.name.toUpperCase() === cat);
                        const displayName = catInfo ? catInfo.name : cat;
                        btn.textContent = `${displayName} (${count})`;
                    }
                }
            });
        }

        // æ£€æŸ¥é¢˜ç›®æ˜¯å¦å·²è§£å‡º
        function isSolved(challengeId) {
            return teamSolves.some(s => s.challengeId === challengeId);
        }

        // æ¸²æŸ“é¢˜ç›®å¡ç‰‡
        function renderChallenges() {
            const grid = document.getElementById('challenges-grid');
            const searchTerm = document.getElementById('search-input').value.toLowerCase();
            const hideSolved = document.getElementById('hide-solved').checked;
            
            let filtered = challengesData.filter(ch => {
                // æ‰€æœ‰ç”¨æˆ·éƒ½åªèƒ½çœ‹åˆ° public çŠ¶æ€çš„é¢˜ç›®ï¼ˆåç«¯å·²è¿‡æ»¤ï¼Œè¿™é‡ŒåŒé‡ä¿é™©ï¼‰
                if (ch.status !== 'public') return false;
                if (currentCategory !== 'ALL' && ch.category !== currentCategory) return false;
                if (searchTerm && !ch.name.toLowerCase().includes(searchTerm)) return false;
                if (hideSolved && isSolved(ch.id)) return false;
                return true;
            });

            // æŒ‰æ˜¾ç¤ºé¡ºåºæ’åºï¼ˆé¡ºåºå·ä¸º0çš„æŒ‰æ·»åŠ é¡ºåºIDæ’ï¼Œå¦åˆ™æŒ‰é¡ºåºå·å‡åºï¼‰
            filtered.sort((a, b) => {
                const orderA = a.displayOrder || 999999;
                const orderB = b.displayOrder || 999999;
                if (orderA !== orderB) return orderA - orderB;
                return (a.id || 0) - (b.id || 0);
            });

            if (filtered.length === 0) {
                grid.innerHTML = `<div class="col-span-full text-center text-gray-500 py-20 font-mono">æš‚æ— é¢˜ç›®</div>`;
                return;
            }

            grid.innerHTML = filtered.map(ch => {
                // è·å–ç±»åˆ«è‡ªå®šä¹‰é¢œè‰²
                const catColor = getCategoryColor(ch.category);
                const solved = isSolved(ch.id);
                
                // å·²è§£å‡ºï¼šåˆ†ç±»æ ‡ç­¾å˜ç°ï¼Œå¦åˆ™ä½¿ç”¨ç±»åˆ«é¢œè‰²
                const labelStyle = solved 
                    ? 'color: #4b5563; border-color: #374151; background-color: #37415120;' 
                    : `color: ${catColor}; border-color: ${catColor}40; background-color: ${catColor}15;`;
                const cardClass = solved ? 'module-card module-solved group' : 'module-card module-normal group';
                const cardStyle = `--cat-color: ${catColor};`;
                // å·²è§£å‡ºï¼šåˆ†æ•°å˜ç°+åˆ é™¤çº¿
                const scoreClass = solved ? 'text-xl font-bold font-eng text-gray-600 line-through' : 'text-xl font-bold font-eng text-white';
                // å·²è§£å‡ºï¼šæ ‡é¢˜å˜ç°
                const titleClass = solved ? 'card-title text-sm font-bold text-gray-500 mt-1 leading-tight line-clamp-2' : 'card-title text-sm font-bold text-gray-200 mt-1 leading-tight transition-colors line-clamp-2';
                // SOLVEDæ°´å° - ä½¿ç”¨ç±»åˆ«é¢œè‰²
                const solvedWatermark = solved ? `<div class="absolute inset-0 flex items-center justify-center pointer-events-none"><span class="font-black font-eng text-5xl -rotate-12 select-none transition" style="color: ${catColor}20;">SOLVED</span></div>` : '';
                // ä¸‰è¡€æ¡æ ·å¼
                const bloodStyle = solved ? {
                    first: 'text-gray-600', firstDot: 'bg-gray-600',
                    second: 'text-gray-600', secondDot: 'bg-gray-700',
                    third: 'text-gray-600', thirdDot: 'bg-gray-800'
                } : {
                    first: ch.firstBlood ? 'text-yellow-500' : 'text-gray-700', firstDot: ch.firstBlood ? 'medal-gold' : 'bg-[#333]',
                    second: ch.secondBlood ? 'text-gray-300' : 'text-gray-700', secondDot: ch.secondBlood ? 'medal-silver' : 'bg-[#333]',
                    third: ch.thirdBlood ? 'text-orange-700' : 'text-gray-700', thirdDot: ch.thirdBlood ? 'medal-bronze' : 'bg-[#333]'
                };

                // åº•è¾¹æ¡æ ·å¼ - å·²è§£å‡ºä½¿ç”¨ç±»åˆ«é¢œè‰²ï¼Œæœªè§£å‡ºä½¿ç”¨é»˜è®¤
                const statusBarStyle = solved ? `background: ${catColor}; height: 4px;` : '';

                return `
                <div onclick="openModal(${ch.id})" class="${cardClass}" style="${cardStyle}">
                    ${solvedWatermark}
                    <div class="p-4 pb-2 flex-grow flex flex-col">
                        <div class="flex justify-between items-start mb-2">
                            <span class="text-[10px] font-mono border px-1.5 py-0.5" style="${labelStyle}">${ch.category}</span>
                            <span class="${scoreClass}">${ch.score}</span>
                        </div>
                        <h3 class="${titleClass}">${ch.name}</h3>
                        <div class="mt-2 text-[10px] text-gray-600 font-mono flex justify-between">
                            <span>è§£å‡º: ${ch.solveCount || 0}</span>
                            ${solved ? `<span style="color: ${catColor};" class="font-bold">âˆš å·²å®Œæˆ</span>` : ''}
                        </div>
                        <div class="blood-bar${solved ? ' border-t-[#222]' : ''}">
                            <div class="blood-item ${bloodStyle.first}"><span class="medal-dot ${bloodStyle.firstDot}"></span> ${ch.firstBlood || '--'}</div>
                            <div class="blood-item ${bloodStyle.second}"><span class="medal-dot ${bloodStyle.secondDot}"></span> ${ch.secondBlood || '--'}</div>
                            <div class="blood-item ${bloodStyle.third}"><span class="medal-dot ${bloodStyle.thirdDot}"></span> ${ch.thirdBlood || '--'}</div>
                        </div>
                    </div>
                    <div class="status-bar" style="${statusBarStyle}"></div>
                </div>
                `;
            }).join('');
        }

        // åˆ†ç±»ç­›é€‰
        document.getElementById('category-bar').addEventListener('click', (e) => {
            if (e.target.classList.contains('cat-btn')) {
                document.querySelectorAll('.cat-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                currentCategory = e.target.dataset.category;
                renderChallenges();
            }
        });

        // æœç´¢
        document.getElementById('search-input').addEventListener('input', renderChallenges);
        document.getElementById('hide-solved').addEventListener('change', renderChallenges);

        // å€’è®¡æ—¶
        let contestEndedHandled = false;
        function startCountdown() {
            function update() {
                if (!contestData) return;
                const endTime = new Date(contestData.endTime.replace(' ', 'T'));
                const now = new Date();
                let diff = Math.max(0, Math.floor((endTime - now) / 1000));
                
                const hours = Math.floor(diff / 3600);
                const minutes = Math.floor((diff % 3600) / 60);
                const seconds = diff % 60;

                document.getElementById('cd-hours').textContent = String(hours).padStart(2, '0');
                document.getElementById('cd-minutes').textContent = String(minutes).padStart(2, '0');
                document.getElementById('cd-seconds').textContent = String(seconds).padStart(2, '0');
                
                // å€’è®¡æ—¶ç»“æŸæ—¶è‡ªåŠ¨å¤„ç†æ¯”èµ›ç»“æŸ
                if (diff === 0 && contestData.status === 'running' && !isAdminMode && !contestEndedHandled) {
                    contestEndedHandled = true;
                    handleContestEnded();
                }
            }
            update();
            setInterval(update, 1000);
        }
        
        // æ¯”èµ›ç»“æŸå¤„ç†
        function handleContestEnded() {
            contestData.status = 'ended';
            // å…³é—­å½“å‰æ‰“å¼€çš„å¼¹çª—
            if (!document.getElementById('modal-overlay').classList.contains('hidden')) {
                closeModal();
                showTip('æ¯”èµ›å·²ç»“æŸ', 'warning');
            }
        }

        // æ‰“å¼€é¢˜ç›®è¯¦æƒ…å¼¹çª—
        function openModal(challengeId) {
            // æ£€æŸ¥æ¯”èµ›çŠ¶æ€ - æ™®é€šç”¨æˆ·åœ¨æ¯”èµ›ç»“æŸåä¸èƒ½æ‰“å¼€é¢˜ç›®
            if (contestData && contestData.status === 'ended' && !isAdminMode) {
                showTip('æ¯”èµ›å·²ç»“æŸ', 'warning');
                return;
            }
            
            currentChallengeId = challengeId;
            const ch = challengesData.find(c => c.id === challengeId);
            if (!ch) return;

            // è·å–ç±»åˆ«é¢œè‰²
            const catColor = getCategoryColor(ch.category);
            const modalCategory = document.getElementById('modal-category');
            modalCategory.textContent = ch.category;
            modalCategory.style.color = catColor;
            modalCategory.style.borderColor = `${catColor}40`;
            modalCategory.style.background = `${catColor}10`;
            
            document.getElementById('modal-score').textContent = `${ch.score} PTS`;
            document.getElementById('modal-title').textContent = ch.name;
            document.getElementById('modal-description').innerHTML = `<p class="mb-6">${ch.description || 'æš‚æ— æè¿°'}</p>`;

            // é™„ä»¶
            const attachmentSection = document.getElementById('attachment-section');
            if (ch.attachmentUrl) {
                attachmentSection.classList.remove('hidden');
                const isLocal = ch.attachmentType === 'local';
                const href = ch.attachmentUrl;
                const targetAttr = isLocal ? '' : 'target="_blank"';
                const downloadAttr = isLocal ? 'download' : '';
                const actionText = isLocal ? 'ç‚¹å‡»ä¸‹è½½' : 'æ‰“å¼€é“¾æ¥';
                document.getElementById('attachment-list').innerHTML = `
                    <a href="${href}" ${targetAttr} ${downloadAttr} class="attachment-card group">
                        <div class="file-icon">ğŸ—‚</div>
                        <div>
                            <div class="text-sm text-gray-300 font-bold group-hover:text-white">é™„ä»¶ä¸‹è½½</div>
                            <div class="text-xs text-gray-600 font-mono">${actionText}</div>
                        </div>
                        <div class="text-gray-600 group-hover:text-[#ff6b00] ml-2 text-lg">â‡©</div>
                    </a>
                `;
            } else {
                attachmentSection.classList.add('hidden');
            }

            // åŠ è½½å·²å‘å¸ƒçš„æç¤º
            loadChallengeHints(challengeId);

            // åŠ¨æ€å®¹å™¨éƒ¨ç½²åŒºåŸŸ - å…ˆé‡ç½®çŠ¶æ€
            const deploySection = document.getElementById('deploy-section');
            const btnDeploy = document.getElementById('btn-deploy');
            const instancePanel = document.getElementById('instance-panel');
            
            // é‡ç½®æ‰€æœ‰çŠ¶æ€
            deploySection.style.display = 'none';
            btnDeploy.style.display = 'none';
            instancePanel.classList.remove('active');
            if (instanceTTLInterval) {
                clearInterval(instanceTTLInterval);
                instanceTTLInterval = null;
            }
            currentInstance = null;
            
            // åŠ¨æ€å®¹å™¨ç±»å‹çš„é¢˜ç›®
            if (ch.type && (ch.type.includes('dynamic') || ch.type.includes('container'))) {
                // å…ˆæ˜¾ç¤ºéƒ¨ç½²åŒºåŸŸå’ŒæŒ‰é’®ï¼ˆé»˜è®¤çŠ¶æ€ï¼‰
                deploySection.style.display = 'block';
                btnDeploy.innerHTML = '<span>ğŸš€ éƒ¨ç½²ä½œæˆ˜ç¯å¢ƒ (DEPLOY INSTANCE)</span>';
                btnDeploy.disabled = false;
                btnDeploy.style.display = 'flex';
                
                // åå°æ£€æŸ¥å®ä¾‹ï¼Œå¦‚æœæœ‰åˆ™åˆ‡æ¢æ˜¾ç¤º
                checkExistingInstance(challengeId);
            }

            // è§£é¢˜æ¦œ
            loadChallengeStats(challengeId);

            // æ£€æŸ¥æ˜¯å¦å·²è§£å‡ºï¼Œæ›´æ–°æäº¤æŒ‰é’®çŠ¶æ€
            const solved = isSolved(challengeId);
            const submitBtn = document.querySelector('.btn-submit-new');
            const flagInput = document.getElementById('flag-input');
            if (solved) {
                submitBtn.textContent = 'å·²è§£å‡º âœ“';
                submitBtn.disabled = true;
                submitBtn.style.background = '#22c55e';
                flagInput.disabled = true;
                flagInput.placeholder = 'å·²è§£å‡ºæ­¤é¢˜';
            } else {
                submitBtn.textContent = 'æäº¤ // SUBMIT';
                submitBtn.disabled = false;
                submitBtn.style.background = '';
                flagInput.disabled = false;
                flagInput.placeholder = 'TG{flag_here...}';
                flagInput.value = '';
            }

            document.getElementById('modal-overlay').classList.remove('hidden');
        }

        function closeModal() {
            document.getElementById('modal-overlay').classList.add('hidden');
            currentChallengeId = null;
        }

        // éƒ¨ç½²å®¹å™¨å®ä¾‹
        let currentInstance = null;
        let instanceTTLInterval = null;

        // æ£€æŸ¥æ˜¯å¦å·²æœ‰è¿è¡Œä¸­çš„å®ä¾‹
        async function checkExistingInstance(challengeId) {
            try {
                const res = await fetch(`/api/contests/${contestId}/challenges/${challengeId}/instance`, {
                    headers: { 'Authorization': 'Bearer ' + token }
                });
                if (res.ok) {
                    const data = await res.json();
                    if (data && data.ports && data.ttl > 0) {
                        currentInstance = data;
                        showInstance(data.ports, data.ttl, data.isOwner, data.creatorName);
                        return true;
                    }
                }
            } catch (e) {
                console.log('No existing instance');
            }
            return false;
        }
        async function deployInstance(forceDestroy = false) {
            const ch = challengesData.find(c => c.id === currentChallengeId);
            if (!ch) return;

            const btnDeploy = document.getElementById('btn-deploy');
            btnDeploy.innerHTML = '<span>ğŸš€ éƒ¨ç½²ä¸­è¯·ç¨å€™...</span>';
            btnDeploy.disabled = true;

            try {
                const url = `/api/contests/${contestId}/challenges/${currentChallengeId}/instance` + (forceDestroy ? '?force=true' : '');
                const res = await fetch(url, {
                    method: 'POST',
                    headers: { 'Authorization': 'Bearer ' + token }
                });
                const data = await res.json();
                
                if (!res.ok) {
                    // å¤„ç†ç‰¹æ®Šé”™è¯¯ç±»å‹
                    if (data.error === 'NEED_DESTROY_OWN') {
                        // éœ€è¦ç¡®è®¤é”€æ¯æ—§å®¹å™¨
                        btnDeploy.innerHTML = '<span>ğŸš€ éƒ¨ç½²ä½œæˆ˜ç¯å¢ƒ (DEPLOY INSTANCE)</span>';
                        btnDeploy.disabled = false;
                        showConfirm('ç¡®è®¤é”€æ¯æ—§å®¹å™¨', 
                            `æ‚¨å·²æœ‰è¿è¡Œä¸­çš„å®¹å™¨ [${data.oldChallengeName}]ï¼Œå¯åŠ¨æ–°å®¹å™¨å°†è‡ªåŠ¨é”€æ¯æ—§å®¹å™¨ã€‚\n\næ˜¯å¦ç»§ç»­ï¼Ÿ`, 
                            () => deployInstance(true));
                        return;
                    } else if (data.error === 'INSTANCE_BY_TEAMMATE' || data.error === 'LIMIT_REACHED' || data.error === 'INSTANCE_EXISTS') {
                        // é˜Ÿå‹å·²å¯åŠ¨æˆ–è¾¾åˆ°é™åˆ¶
                        btnDeploy.innerHTML = '<span>ğŸš€ éƒ¨ç½²ä½œæˆ˜ç¯å¢ƒ (DEPLOY INSTANCE)</span>';
                        btnDeploy.disabled = false;
                        showTip(data.message, 'warning');
                        return;
                    }
                    throw new Error(data.message || 'éƒ¨ç½²å¤±è´¥');
                }

                // éƒ¨ç½²æˆåŠŸï¼Œæ˜¾ç¤ºè¿›åº¦æ¡åŠ¨ç”»
                currentInstance = data;
                showDeployProgress(() => {
                    showInstance(data.ports, data.ttl, true, ''); // è‡ªå·±åˆ›å»ºçš„ï¼ŒisOwner=true
                });
            } catch (e) {
                showTip('éƒ¨ç½²å¤±è´¥: ' + e.message, 'error');
                btnDeploy.innerHTML = '<span>ğŸš€ éƒ¨ç½²ä½œæˆ˜ç¯å¢ƒ (DEPLOY INSTANCE)</span>';
                btnDeploy.disabled = false;
            }
        }

        // æ˜¾ç¤ºéƒ¨ç½²è¿›åº¦æ¡åŠ¨ç”»ï¼ˆ5ç§’ï¼‰
        function showDeployProgress(onComplete) {
            const btnDeploy = document.getElementById('btn-deploy');
            const progressPanel = document.getElementById('deploy-progress-panel');
            const progressBar = document.getElementById('deploy-progress-bar');
            const progressText = document.getElementById('deploy-progress-text');
            
            // éšè—æŒ‰é’®ï¼Œæ˜¾ç¤ºè¿›åº¦æ¡
            btnDeploy.style.display = 'none';
            progressPanel.style.display = 'block';
            progressBar.style.width = '0%';
            progressText.textContent = '0%';
            
            let progress = 0;
            const duration = 5000; // 5ç§’
            const interval = 50;   // æ¯50msæ›´æ–°ä¸€æ¬¡
            const step = 100 / (duration / interval);
            
            const timer = setInterval(() => {
                progress += step;
                if (progress >= 100) {
                    progress = 100;
                    clearInterval(timer);
                    progressBar.style.width = '100%';
                    progressText.textContent = '100%';
                    // ç¨å¾®å»¶è¿Ÿåæ˜¾ç¤ºç»“æœ
                    setTimeout(() => {
                        progressPanel.style.display = 'none';
                        onComplete();
                    }, 300);
                } else {
                    progressBar.style.width = progress + '%';
                    progressText.textContent = Math.floor(progress) + '%';
                }
            }, interval);
        }

        function showInstance(ports, ttlSeconds, isOwner = true, creatorName = '') {
            document.getElementById('btn-deploy').style.display = 'none';
            const instancePanel = document.getElementById('instance-panel');
            instancePanel.classList.add('active');

            // æ˜¾ç¤ºåˆ›å»ºè€…ä¿¡æ¯å’Œæ§åˆ¶é”€æ¯æŒ‰é’®
            const creatorInfo = document.getElementById('instance-creator-info');
            const destroyBtn = document.getElementById('btn-destroy');
            if (!isOwner && creatorName) {
                creatorInfo.textContent = `(ç”± ${creatorName} å¯åŠ¨)`;
                creatorInfo.style.display = 'inline';
                destroyBtn.style.display = 'none';
            } else {
                creatorInfo.style.display = 'none';
                destroyBtn.style.display = 'inline';
            }

            // å¡«å……åœ°å€ - ä½¿ç”¨å½“å‰ä¸»æœºå + ç«¯å£
            const addressesDiv = document.getElementById('instance-addresses');
            const host = window.location.hostname; // å½“å‰ç½‘ç«™ä¸»æœº
            
            // æ£€æŸ¥ç«¯å£æ˜¯å¦ä¸ºç©º
            if (!ports || Object.keys(ports).length === 0) {
                addressesDiv.innerHTML = `
                    <div class="text-yellow-500 text-sm">âš ï¸ å®¹å™¨å·²å¯åŠ¨ï¼Œä½†æœªé…ç½®ç«¯å£æ˜ å°„</div>
                    <div class="text-gray-500 text-xs mt-1">è¯·è”ç³»ç®¡ç†å‘˜æ£€æŸ¥é¢˜ç›®é…ç½®</div>
                `;
            } else {
                const addresses = Object.entries(ports).map(([containerPort, hostPort]) => 
                    `${host}:${hostPort}`
                );

                addressesDiv.innerHTML = addresses.map(addr => `
                    <div class="instance-row group">
                        <span class="addr-text">${addr}</span>
                        <span class="copy-icon group-hover:text-[#ff6b00]" data-copy="${addr}" title="å¤åˆ¶" style="cursor:pointer">ğŸ“‹</span>
                        <a href="http://${addr}" target="_blank" class="text-[#3b82f6] hover:text-white" title="ç”¨ç½‘é¡µæ‰“å¼€">ğŸŒ</a>
                    </div>
                `).join('');

                // ç»‘å®šå¤åˆ¶äº‹ä»¶
                addressesDiv.querySelectorAll('.copy-icon').forEach(btn => {
                    btn.onclick = function() {
                        copyToClipboard(this.dataset.copy);
                    };
                });
            }

            // å¯åŠ¨å€’è®¡æ—¶
            startInstanceTTL(ttlSeconds);
        }

        function startInstanceTTL(seconds) {
            let remaining = seconds;
            updateInstanceTTL(remaining);

            if (instanceTTLInterval) clearInterval(instanceTTLInterval);
            instanceTTLInterval = setInterval(() => {
                remaining--;
                if (remaining <= 0) {
                    clearInterval(instanceTTLInterval);
                    // å®ä¾‹è¿‡æœŸï¼Œé‡ç½®ç•Œé¢
                    resetInstanceUI();
                    alert('å®ä¾‹å·²è¿‡æœŸ');
                    return;
                }
                updateInstanceTTL(remaining);
            }, 1000);
        }

        function updateInstanceTTL(seconds) {
            const ttlEl = document.getElementById('instance-ttl');
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            ttlEl.textContent = `${mins}:${String(secs).padStart(2, '0')}`;
        }

        function copyToClipboard(text) {
            // å…ˆå°è¯•ç°ä»£ API
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(text).then(() => {
                    showCopyTip('å·²å¤åˆ¶: ' + text);
                }).catch(() => {
                    fallbackCopy(text);
                });
            } else {
                fallbackCopy(text);
            }
        }

        function fallbackCopy(text) {
            const ta = document.createElement('textarea');
            ta.value = text;
            ta.style.position = 'fixed';
            ta.style.left = '-9999px';
            document.body.appendChild(ta);
            ta.focus();
            ta.select();
            try {
                document.execCommand('copy');
                showCopyTip('å·²å¤åˆ¶: ' + text);
            } catch (e) {
                alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶: ' + text);
            }
            document.body.removeChild(ta);
        }

        function showCopyTip(msg) {
            // ç®€å•æç¤º
            const tip = document.createElement('div');
            tip.textContent = msg;
            tip.style.cssText = 'position:fixed;top:20px;left:50%;transform:translateX(-50%);background:#22c55e;color:#fff;padding:8px 16px;border-radius:4px;z-index:9999;font-size:14px;';
            document.body.appendChild(tip);
            setTimeout(() => tip.remove(), 1500);
        }

        // é€šç”¨æç¤ºå‡½æ•°
        function showTip(msg, type = 'info') {
            const colors = {
                'success': '#22c55e',
                'error': '#ef4444',
                'warning': '#f59e0b',
                'info': '#3b82f6'
            };
            const tip = document.createElement('div');
            tip.textContent = msg;
            tip.style.cssText = `position:fixed;top:20px;left:50%;transform:translateX(-50%);background:${colors[type] || colors.info};color:#fff;padding:12px 20px;border-radius:4px;z-index:9999;font-size:14px;max-width:80%;text-align:center;`;
            document.body.appendChild(tip);
            setTimeout(() => tip.remove(), 3000);
        }

        function extendInstance() {
            fetch(`/api/contests/${contestId}/challenges/${currentChallengeId}/instance/extend`, {
                method: 'POST',
                headers: { 'Authorization': 'Bearer ' + token }
            })
            .then(res => res.json())
            .then(data => {
                if (data.ttl) {
                    startInstanceTTL(data.ttl);
                    alert('å·²å»¶é•¿30åˆ†é’Ÿ');
                } else {
                    alert(data.message || 'å»¶é•¿å¤±è´¥');
                }
            })
            .catch(e => alert('å»¶é•¿å¤±è´¥: ' + e.message));
        }

        function destroyInstance() {
            showConfirm('ç¡®è®¤é”€æ¯', 'ç¡®å®šè¦é”€æ¯å½“å‰å®¹å™¨å®ä¾‹å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚', doDestroyInstance);
        }

        function doDestroyInstance() {
            fetch(`/api/contests/${contestId}/challenges/${currentChallengeId}/instance`, {
                method: 'DELETE',
                headers: { 'Authorization': 'Bearer ' + token }
            })
            .then(res => res.json().then(data => ({ok: res.ok, data})))
            .then(({ok, data}) => {
                if (!ok) {
                    if (data.error === 'NOT_OWNER') {
                        showTip(data.message, 'warning');
                    } else {
                        showTip(data.message || 'é”€æ¯å¤±è´¥', 'error');
                    }
                    return;
                }
                resetInstanceUI();
                showCopyTip('å®¹å™¨å·²é”€æ¯');
            })
            .catch(e => showTip('é”€æ¯å¤±è´¥: ' + e.message, 'error'));
        }

        // è‡ªå®šä¹‰ç¡®è®¤å¼¹çª—
        let confirmCallback = null;
        function showConfirm(title, msg, onConfirm) {
            document.getElementById('confirm-title').textContent = title;
            document.getElementById('confirm-msg').textContent = msg;
            confirmCallback = onConfirm;
            document.getElementById('confirm-overlay').classList.remove('hidden');
        }
        function hideConfirm() {
            document.getElementById('confirm-overlay').classList.add('hidden');
            confirmCallback = null;
        }
        document.getElementById('confirm-ok-btn').onclick = function() {
            const cb = confirmCallback;
            hideConfirm();
            if (cb) cb();
        };

        function resetInstanceUI() {
            if (instanceTTLInterval) {
                clearInterval(instanceTTLInterval);
                instanceTTLInterval = null;
            }
            currentInstance = null;

            const instancePanel = document.getElementById('instance-panel');
            instancePanel.classList.remove('active');
            
            const btnDeploy = document.getElementById('btn-deploy');
            btnDeploy.innerHTML = '<span>ğŸš€ éƒ¨ç½²ä½œæˆ˜ç¯å¢ƒ (DEPLOY INSTANCE)</span>';
            btnDeploy.disabled = false;
            btnDeploy.style.display = 'flex';
        }

        // åŠ è½½é¢˜ç›®å·²å‘å¸ƒçš„æç¤º
        async function loadChallengeHints(challengeId) {
            const hintsSection = document.getElementById('hints-section');
            const hintsList = document.getElementById('hints-list');
            
            // é»˜è®¤éšè—
            hintsSection.classList.add('hidden');
            hintsList.innerHTML = '';
            
            try {
                const res = await fetch(`/api/contests/${contestId}/challenges/${challengeId}/hints`, {
                    headers: { 'Authorization': 'Bearer ' + token }
                });
                if (!res.ok) return;
                
                const hints = await res.json() || [];
                
                if (hints.length > 0) {
                    hintsSection.classList.remove('hidden');
                    hintsList.innerHTML = hints.map((hint, idx) => `
                        <div class="bg-[#1a1a1a] border border-[#333] p-3 mb-2 last:mb-0">
                            <div class="flex items-start gap-2">
                                <span class="text-yellow-500 text-sm">ğŸ’¡</span>
                                <div class="flex-1">
                                    <p class="text-gray-300 text-sm">${escapeHtml(hint.content)}</p>
                                    <p class="text-gray-600 text-[10px] mt-1 font-mono">æç¤º ${idx + 1} Â· ${formatHintTime(hint.releasedAt)}</p>
                                </div>
                            </div>
                        </div>
                    `).join('');
                }
            } catch (e) {
                console.error('åŠ è½½æç¤ºå¤±è´¥', e);
            }
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function formatHintTime(isoString) {
            if (!isoString) return '';
            const d = new Date(isoString);
            return d.toLocaleString('zh-CN', { month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' });
        }

        // åŠ è½½é¢˜ç›®ç»Ÿè®¡ï¼ˆè§£é¢˜æ¦œï¼‰
        async function loadChallengeStats(challengeId) {
            const solversList = document.getElementById('solvers-list');
            solversList.innerHTML = `<tr><td class="p-4 text-gray-500 text-center">åŠ è½½ä¸­...</td></tr>`;

            try {
                const res = await fetch(`/api/contests/${contestId}/challenges/${challengeId}/stats`, {
                    headers: { 'Authorization': 'Bearer ' + token }
                });
                if (!res.ok) throw new Error('Failed');
                const data = await res.json();

                // æ›´æ–°é¢˜ç›®å¡ç‰‡æ•°æ®
                const ch = challengesData.find(c => c.id === challengeId);
                if (ch) {
                    ch.solveCount = data.solveCount || 0;
                    if (data.firstBlood) ch.firstBlood = data.firstBlood.teamName;
                    if (data.secondBlood) ch.secondBlood = data.secondBlood.teamName;
                    if (data.thirdBlood) ch.thirdBlood = data.thirdBlood.teamName;
                }

                // æ¸²æŸ“è§£é¢˜æ¦œ - æ˜¾ç¤ºæ‰€æœ‰è§£é¢˜è€…
                const solvers = data.solvers || [];
                if (solvers.length > 0) {
                    let html = '';
                    solvers.forEach((solver, index) => {
                        let rowClass = '';
                        let icon = '';
                        let textClass = 'text-gray-400';
                        let medalDot = '';
                        
                        if (index === 0) {
                            rowClass = 'bg-yellow-500/10';
                            icon = 'ğŸ¥‡ ';
                            textClass = 'text-yellow-500';
                            medalDot = '<span class="medal-dot medal-gold mr-2"></span>';
                        } else if (index === 1) {
                            rowClass = 'bg-gray-500/5';
                            icon = 'ğŸ¥ˆ ';
                            textClass = 'text-gray-300';
                            medalDot = '<span class="medal-dot medal-silver mr-2"></span>';
                        } else if (index === 2) {
                            rowClass = 'bg-orange-500/5';
                            icon = 'ğŸ¥‰ ';
                            textClass = 'text-orange-700';
                            medalDot = '<span class="medal-dot medal-bronze mr-2"></span>';
                        }
                        
                        html += `<tr class="${rowClass}">
                            <td class="p-3">
                                ${medalDot}<span class="${textClass} text-sm font-medium">${icon}${solver.teamName}</span>
                            </td>
                            <td class="text-gray-500 text-right pr-4 text-xs">${solver.solvedAt}</td>
                        </tr>`;
                    });
                    solversList.innerHTML = html;
                } else {
                    solversList.innerHTML = `<tr><td class="p-4 text-gray-500 text-center">æš‚æ— è§£é¢˜è®°å½•</td></tr>`;
                }
            } catch (e) {
                solversList.innerHTML = `<tr><td class="p-4 text-gray-500 text-center">æš‚æ— è§£é¢˜è®°å½•</td></tr>`;
            }
        }

        // æ˜¾ç¤ºè‡ªå®šä¹‰å¼¹çª—æç¤º
        function showToast(message, type = 'info') {
            const colors = {
                success: '#22c55e',
                error: '#ef4444',
                info: '#3b82f6',
                warning: '#f59e0b'
            };
            const tip = document.createElement('div');
            tip.textContent = message;
            tip.style.cssText = `position:fixed;top:20px;left:50%;transform:translateX(-50%);background:${colors[type] || colors.info};color:#fff;padding:12px 24px;border-radius:4px;z-index:9999;font-size:14px;box-shadow:0 4px 12px rgba(0,0,0,0.3);`;
            document.body.appendChild(tip);
            setTimeout(() => tip.remove(), 3000);
        }

        // æäº¤ Flag
        let flagCooldownTimer = null;
        let flagCooldownSeconds = 0;

        async function submitFlag() {
            const flag = document.getElementById('flag-input').value.trim();
            if (!flag) {
                showToast('è¯·è¾“å…¥ Flag', 'warning');
                return;
            }

            // æ£€æŸ¥æ˜¯å¦åœ¨å†·å´ä¸­
            if (flagCooldownSeconds > 0) {
                showToast(`è¯·ç­‰å¾… ${flagCooldownSeconds} ç§’åå†æäº¤`, 'warning');
                return;
            }

            if (isAdminMode) {
                // è¶…çº§ç®¡ç†å‘˜æ¨¡å¼ï¼šä»…éªŒè¯ flag æ­£ç¡®æ€§ï¼Œä¸è®°å½•
                const ch = challengesData.find(c => c.id === currentChallengeId);
                if (ch && flag === ch.flag) {
                    showToast('âœ“ Flag æ­£ç¡®ï¼ï¼ˆç®¡ç†å‘˜æ¨¡å¼ï¼Œä¸è®¡å…¥åˆ†æ•°ï¼‰', 'success');
                } else {
                    showToast('âœ— Flag é”™è¯¯', 'error');
                }
                return;
            }

            // æ™®é€šç”¨æˆ·æäº¤
            const submitBtn = document.querySelector('.btn-submit-new');
            submitBtn.textContent = 'æäº¤ä¸­...';
            submitBtn.disabled = true;

            try {
                const res = await fetch(`/api/contests/${contestId}/challenges/${currentChallengeId}/submit`, {
                    method: 'POST',
                    headers: {
                        'Authorization': 'Bearer ' + token,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ flag: flag })
                });
                const data = await res.json();

                if (data.correct) {
                    // æ­£ç¡®
                    let msg = data.message || 'å›ç­”æ­£ç¡®ï¼';
                    if (data.score) msg += ` +${data.score}åˆ†`;
                    showToast(msg, 'success');

                    // æ›´æ–°ç•Œé¢
                    submitBtn.textContent = 'å·²è§£å‡º âœ“';
                    submitBtn.style.background = '#22c55e';
                    document.getElementById('flag-input').disabled = true;

                    // é‡æ–°åŠ è½½è§£é¢˜çŠ¶æ€
                    await loadTeamSolves();
                    loadChallengeStats(currentChallengeId);
                } else if (data.error === 'TOO_FAST') {
                    // æäº¤å¤ªé¢‘ç¹ï¼Œå¯åŠ¨å†·å´å€’è®¡æ—¶
                    startFlagCooldown(data.retryAfter || 10);
                    submitBtn.disabled = false;
                } else {
                    // é”™è¯¯ï¼Œå¯åŠ¨å†·å´å€’è®¡æ—¶
                    showToast(data.message || 'Flagé”™è¯¯', 'error');
                    startFlagCooldown(10);
                }
            } catch (e) {
                showToast('æäº¤å¤±è´¥: ' + e.message, 'error');
                submitBtn.textContent = 'æäº¤ // SUBMIT';
                submitBtn.disabled = false;
            }
        }

        // å¯åŠ¨ flag æäº¤å†·å´å€’è®¡æ—¶
        function startFlagCooldown(seconds) {
            const submitBtn = document.querySelector('.btn-submit-new');
            flagCooldownSeconds = seconds;
            
            if (flagCooldownTimer) clearInterval(flagCooldownTimer);
            
            updateFlagCooldownUI();
            
            flagCooldownTimer = setInterval(() => {
                flagCooldownSeconds--;
                if (flagCooldownSeconds <= 0) {
                    clearInterval(flagCooldownTimer);
                    flagCooldownTimer = null;
                    flagCooldownSeconds = 0;
                    submitBtn.textContent = 'æäº¤ // SUBMIT';
                    submitBtn.disabled = false;
                } else {
                    updateFlagCooldownUI();
                }
            }, 1000);
        }

        function updateFlagCooldownUI() {
            const submitBtn = document.querySelector('.btn-submit-new');
            submitBtn.textContent = `è¯·ç­‰å¾… ${flagCooldownSeconds}s`;
            submitBtn.disabled = true;
        }

        // ESC å…³é—­å¼¹çª—
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') closeModal();
        });

        // ========== å…¬å‘ŠåŠŸèƒ½ ==========
        let announcementsData = [];

        async function loadAnnouncements() {
            try {
                const res = await fetch(`/api/contests/${contestId}/announcements`, {
                    headers: { 'Authorization': 'Bearer ' + token }
                });
                if (!res.ok) return;
                announcementsData = await res.json() || [];
                renderAnnouncements();
            } catch (e) {
                console.error('åŠ è½½å…¬å‘Šå¤±è´¥:', e);
            }
        }

        function renderAnnouncements() {
            const container = document.getElementById('event-log');
            if (!container) return;

            if (announcementsData.length === 0) {
                container.innerHTML = `
                    <div class="event-item">
                        <div class="flex justify-between items-center"><span class="tag-event tag-sys">ç³»ç»Ÿ</span><span class="text-gray-600 font-mono">--:--:--</span></div>
                        <p class="text-gray-400">æš‚æ— å…¬å‘Š</p>
                    </div>
                `;
                return;
            }

            const typeConfig = {
                'manual': { tag: 'å…¬å‘Š', tagClass: 'tag-sys', icon: 'ğŸ“¢' },
                'challenge_open': { tag: 'æ–°é¢˜', tagClass: 'tag-new', icon: 'âœ…' },
                'challenge_close': { tag: 'ä¸‹æ¶', tagClass: 'tag-sys', icon: 'âŒ' },
                'first_blood': { tag: 'ä¸€è¡€', tagClass: 'tag-blood', icon: 'ğŸ¥‡' },
                'second_blood': { tag: 'äºŒè¡€', tagClass: 'tag-blood', icon: 'ğŸ¥ˆ' },
                'third_blood': { tag: 'ä¸‰è¡€', tagClass: 'tag-blood', icon: 'ğŸ¥‰' },
                'cheating': { tag: 'è­¦å‘Š', tagClass: 'tag-hint', icon: 'âš ï¸' }
            };

            container.innerHTML = announcementsData.map(ann => {
                const cfg = typeConfig[ann.type] || { tag: 'é€šçŸ¥', tagClass: 'tag-sys', icon: 'ğŸ“£' };
                const time = ann.createdAt ? ann.createdAt.split(' ')[1] || ann.createdAt : '--:--:--';
                return `
                    <div class="event-item">
                        <div class="flex justify-between items-center">
                            <span class="tag-event ${cfg.tagClass}">${cfg.icon} ${cfg.tag}</span>
                            <span class="text-gray-600 font-mono text-[10px]">${time}</span>
                        </div>
                        <p class="text-gray-300 text-[11px] leading-relaxed">${escapeHtml(ann.title)}</p>
                        ${ann.content ? `<p class="text-gray-500 text-[10px] mt-1">${escapeHtml(ann.content)}</p>` : ''}
                    </div>
                `;
            }).join('');
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // åŠ è½½æ‰€æœ‰é¢˜ç›®çš„ä¸€äºŒä¸‰è¡€æ•°æ®ï¼ˆä½¿ç”¨æ‰¹é‡æ¥å£ï¼Œä¸è®°å½•é¦–æ¬¡æŸ¥çœ‹ï¼‰
        async function loadAllBloodStats() {
            if (challengesData.length === 0) return;
            try {
                const res = await fetch(`/api/contests/${contestId}/challenges/blood`, {
                    headers: { 'Authorization': 'Bearer ' + token }
                });
                if (!res.ok) return;
                const bloodData = await res.json() || [];
                // å°†è¡€é‡æ•°æ®æ˜ å°„åˆ°é¢˜ç›®
                const bloodMap = {};
                bloodData.forEach(b => { bloodMap[b.challengeId] = b; });
                challengesData.forEach(ch => {
                    const blood = bloodMap[ch.id];
                    if (blood) {
                        ch.solveCount = blood.solveCount || 0;
                        ch.firstBlood = blood.firstBlood || null;
                        ch.secondBlood = blood.secondBlood || null;
                        ch.thirdBlood = blood.thirdBlood || null;
                    }
                });
                renderChallenges();
            } catch (e) {
                console.error('loadAllBloodStats error:', e);
            }
        }

        // å®šæ—¶åˆ·æ–°å…¬å‘Š (5ç§’)
        setInterval(loadAnnouncements, 5000);

        // å®šæ—¶åˆ·æ–°é¢˜ç›®ä¸€äºŒä¸‰è¡€ (10ç§’)
        setInterval(loadAllBloodStats, 10000);

        // å®šæ—¶æ£€æŸ¥å°ç¦çŠ¶æ€ (3ç§’) - å®æ—¶ç›‘æ§
        if (!isAdminMode) {
            setInterval(checkBannedStatus, 3000);
        }

        // å®šæ—¶åˆ·æ–°é¢˜ç›®åˆ—è¡¨ (5ç§’) - è‡ªåŠ¨æ£€æµ‹æ–°å¼€æ”¾çš„é¢˜ç›®
        setInterval(async () => {
            try {
                const res = await fetch(`/api/contests/${contestId}/challenges`, {
                    headers: { 'Authorization': 'Bearer ' + token }
                });
                if (!res.ok) return;
                const newChallenges = await res.json() || [];
                // æ£€æŸ¥æ˜¯å¦æœ‰æ–°é¢˜ç›®
                const oldIds = new Set(challengesData.map(c => c.id));
                const newIds = new Set(newChallenges.map(c => c.id));
                const hasNewChallenge = newChallenges.some(c => !oldIds.has(c.id));
                const hasRemovedChallenge = challengesData.some(c => !newIds.has(c.id));
                if (hasNewChallenge || hasRemovedChallenge || newChallenges.length !== challengesData.length) {
                    // ä¿ç•™æ—§é¢˜ç›®çš„ä¸€äºŒä¸‰è¡€æ•°æ®
                    const oldBloodData = {};
                    challengesData.forEach(ch => {
                        oldBloodData[ch.id] = { firstBlood: ch.firstBlood, secondBlood: ch.secondBlood, thirdBlood: ch.thirdBlood, solveCount: ch.solveCount };
                    });
                    challengesData = newChallenges;
                    challengesData.forEach(ch => {
                        if (oldBloodData[ch.id]) {
                            Object.assign(ch, oldBloodData[ch.id]);
                        }
                    });
                    updateCategoryCounts();
                    renderChallenges();
                    loadAllBloodStats();
                }
            } catch (e) {}
        }, 5000);

        // è·³è½¬åˆ°æ’è¡Œæ¦œ
        function goToLeaderboard() {
            window.location.href = `/contest-leaderboard.html?id=${contestId}`;
        }

        // ========== WebSocket å®æ—¶æ›´æ–° ==========
        let challengeWs = null;

        function initChallengeWebSocket() {
            if (!contestId || !token) return;
            
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${wsProtocol}//${window.location.host}/api/contests/${contestId}/monitor/ws?token=${token}`;
            
            challengeWs = new WebSocket(wsUrl);
            
            challengeWs.onopen = () => {
                console.log('[WS] Challenge WebSocket connected');
            };
            
            challengeWs.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    handleWebSocketUpdate(data);
                } catch (e) {
                    console.error('[WS] Parse error:', e);
                }
            };
            
            challengeWs.onclose = () => {
                console.log('[WS] Challenge WebSocket closed, reconnecting in 3s...');
                setTimeout(initChallengeWebSocket, 3000);
            };
            
            challengeWs.onerror = (e) => {
                console.error('[WS] WebSocket error:', e);
            };
        }

        function handleWebSocketUpdate(data) {
            // æ”¶åˆ°è§£é¢˜æ›´æ–°ï¼Œé‡æ–°åŠ è½½æ‰€æœ‰é¢˜ç›®çš„åˆ†æ•°å’Œä¸€äºŒä¸‰è¡€æ•°æ®
            if (data.solves && Array.isArray(data.solves) && data.solves.length > 0) {
                loadAllBloodStats();
            }

            // å¦‚æœå¼¹çª—æ‰“å¼€ï¼Œå®æ—¶æ›´æ–°è§£é¢˜æ¦œå’Œåˆ†æ•°
            if (currentChallengeId) {
                updateModalFromWebSocket(data);
            }
        }

        function updateModalFromWebSocket(data) {
            if (!data.solves) return;
            
            // ç­›é€‰å½“å‰é¢˜ç›®çš„è§£é¢˜è®°å½•
            const currentSolves = data.solves.filter(s => s.challengeId === currentChallengeId);
            if (currentSolves.length === 0) return;

            // æœ‰æ–°è§£é¢˜è®°å½•ï¼Œé‡æ–°åŠ è½½é¢˜ç›®ç»Ÿè®¡ï¼ˆè·å–æ­£ç¡®çš„å½“å‰åˆ†æ•°å’Œè§£é¢˜æ¦œï¼‰
            loadChallengeStats(currentChallengeId);
        }

        // åˆå§‹åŒ–
        init();
        // åˆå§‹åŒ– WebSocket
        setTimeout(initChallengeWebSocket, 1000);

        // åŠ è½½ç”¨æˆ·å¤´åƒ
        async function loadUserAvatar() {
            try {
                const res = await fetch('/api/profile', {
                    headers: { 'Authorization': 'Bearer ' + token }
                });
                if (res.ok) {
                    const data = await res.json();
                    if (data.avatar) {
                        const avatarImg = document.getElementById('user-avatar-img');
                        const avatarText = document.getElementById('user-avatar');
                        avatarImg.src = data.avatar;
                        avatarImg.classList.remove('hidden');
                        avatarText.classList.add('hidden');
                    } else {
                        document.getElementById('user-avatar').textContent = (data.displayName || data.username || 'U')[0].toUpperCase();
                    }
                }
            } catch (e) {
                console.error('Load avatar error:', e);
            }
        }
    </script>

</body>
</html>
